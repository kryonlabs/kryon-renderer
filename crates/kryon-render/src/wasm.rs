// WASM module for embedding WebAssembly modules in Kryon UI
// This provides a basic foundation for WASM integration

#[cfg(feature = "wasm")]
use wasmtime::{Engine, Store, Module, Instance, Linker, TypedFunc};
use std::collections::HashMap;
use glam::Vec2;
use crate::{RenderCommand, RenderResult, RenderError};

/// Basic WASM module manager for Kryon
pub struct WasmManager {
    #[cfg(feature = "wasm")]
    engine: Engine,
    #[cfg(feature = "wasm")]
    linker: Linker<WasmState>,
    modules: HashMap<String, WasmModuleInstance>,
}

/// Runtime state for WASM modules
pub struct WasmState {
    pub render_commands: Vec<RenderCommand>,
    pub viewport_size: Vec2,
}

/// Represents a loaded WASM module instance
pub struct WasmModuleInstance {
    #[cfg(feature = "wasm")]
    instance: Instance,
    #[cfg(feature = "wasm")]
    store: Store<WasmState>,
    pub module_id: String,
    pub viewport_size: Vec2,
}

impl WasmManager {
    /// Create a new WASM manager
    pub fn new() -> RenderResult<Self> {
        #[cfg(feature = "wasm")]
        {
            let engine = Engine::default();
            let mut linker = Linker::new(&engine);
            
            // Add host functions that WASM modules can call
            Self::register_host_functions(&mut linker)?;
            
            Ok(Self {
                engine,
                linker,
                modules: HashMap::new(),
            })
        }
        
        #[cfg(not(feature = "wasm"))]
        {
            Ok(Self {
                modules: HashMap::new(),
            })
        }
    }
    
    /// Load a WASM module from file
    pub fn load_module(&mut self, module_id: String, wasm_path: &str, viewport_size: Vec2) -> RenderResult<()> {
        #[cfg(feature = "wasm")]
        {
            // Read the WASM file
            let wasm_bytes = std::fs::read(wasm_path)
                .map_err(|e| RenderError::ResourceNotFound(format!("Failed to read WASM file {}: {}", wasm_path, e)))?;
            
            // Compile the module
            let module = Module::new(&self.engine, &wasm_bytes)
                .map_err(|e| RenderError::RenderFailed(format!("Failed to compile WASM module: {}", e)))?;
            
            // Create instance state
            let wasm_state = WasmState {
                render_commands: Vec::new(),
                viewport_size,
            };
            
            let mut store = Store::new(&self.engine, wasm_state);
            
            // Instantiate the module
            let instance = self.linker.instantiate(&mut store, &module)
                .map_err(|e| RenderError::RenderFailed(format!("Failed to instantiate WASM module: {}", e)))?;
            
            let module_instance = WasmModuleInstance {
                instance,
                store,
                module_id: module_id.clone(),
                viewport_size,
            };
            
            self.modules.insert(module_id, module_instance);
            
            eprintln!("[WASM] Successfully loaded module from: {}", wasm_path);
        }
        
        #[cfg(not(feature = "wasm"))]
        {
            eprintln!("[WASM] WASM support not compiled in, skipping module load: {}", wasm_path);
        }
        
        Ok(())
    }
    
    /// Execute a function in a loaded WASM module
    pub fn execute_function(&mut self, module_id: &str, function_name: &str, params: &[f64]) -> RenderResult<Vec<RenderCommand>> {
        #[cfg(feature = "wasm")]
        {
            if let Some(module_instance) = self.modules.get_mut(module_id) {
                // Clear previous render commands
                module_instance.store.data_mut().render_commands.clear();
                
                // Get the function from the WASM instance
                let func = module_instance.instance
                    .get_typed_func::<(), ()>(&mut module_instance.store, function_name)
                    .map_err(|e| RenderError::RenderFailed(format!("Function '{}' not found: {}", function_name, e)))?;
                
                // Call the function
                func.call(&mut module_instance.store, ())
                    .map_err(|e| RenderError::RenderFailed(format!("WASM function execution failed: {}", e)))?;
                
                // Return the render commands generated by the WASM module
                Ok(module_instance.store.data().render_commands.clone())
            } else {
                Err(RenderError::ResourceNotFound(format!("WASM module '{}' not found", module_id)))
            }
        }
        
        #[cfg(not(feature = "wasm"))]
        {
            eprintln!("[WASM] WASM support not compiled in, skipping function execution: {}::{}", module_id, function_name);
            Ok(vec![])
        }
    }
    
    /// Register host functions that WASM modules can call
    #[cfg(feature = "wasm")]
    fn register_host_functions(linker: &mut Linker<WasmState>) -> RenderResult<()> {
        // Basic drawing functions that WASM modules can call
        linker.func_wrap("host", "draw_rect", |mut caller: wasmtime::Caller<'_, WasmState>, x: f32, y: f32, w: f32, h: f32, r: f32, g: f32, b: f32, a: f32| {
            let command = RenderCommand::DrawCanvasRect {
                position: Vec2::new(x, y),
                size: Vec2::new(w, h),
                fill_color: Some(glam::Vec4::new(r, g, b, a)),
                stroke_color: None,
                stroke_width: 0.0,
            };
            caller.data_mut().render_commands.push(command);
        }).map_err(|e| RenderError::RenderFailed(format!("Failed to register host function: {}", e)))?;
        
        linker.func_wrap("host", "draw_text", |mut caller: wasmtime::Caller<'_, WasmState>, x: f32, y: f32, size: f32, r: f32, g: f32, b: f32, a: f32| {
            let command = RenderCommand::DrawCanvasText {
                position: Vec2::new(x, y),
                text: "WASM Text".to_string(), // For now, hardcoded text
                font_size: size,
                color: glam::Vec4::new(r, g, b, a),
            };
            caller.data_mut().render_commands.push(command);
        }).map_err(|e| RenderError::RenderFailed(format!("Failed to register host function: {}", e)))?;
        
        // Console log function for debugging
        linker.func_wrap("host", "console_log", |_caller: wasmtime::Caller<'_, WasmState>, value: i32| {
            eprintln!("[WASM_LOG] {}", value);
        }).map_err(|e| RenderError::RenderFailed(format!("Failed to register host function: {}", e)))?;
        
        Ok(())
    }
    
    /// Get viewport size for a module
    pub fn get_viewport_size(&self, module_id: &str) -> Option<Vec2> {
        self.modules.get(module_id).map(|m| m.viewport_size)
    }
}

impl Default for WasmManager {
    fn default() -> Self {
        Self::new().unwrap_or_else(|_| {
            #[cfg(feature = "wasm")]
            {
                Self {
                    engine: Engine::default(),
                    linker: Linker::new(&Engine::default()),
                    modules: HashMap::new(),
                }
            }
            #[cfg(not(feature = "wasm"))]
            {
                Self {
                    modules: HashMap::new(),
                }
            }
        })
    }
}